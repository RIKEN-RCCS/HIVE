# Hive Module specification

## HIVE 可視化モジュール仕様

## info.json

モジュール化するにあたり、モジュールの名前などの諸情報、インプットとアウトプットの定義を JSON 形式で記述し、ファイル名を info.json とする。

記述例：

```
{
	"name": "モジュール名",
	"funcname": "関数名",
	"info": "モジュールに関する説明",
	"customfuncfile": "対になるLuaスクリプト",
	"input": [
    {"name": "プロパティ名", "type": "データタイプ", "value": "値"}
	],
	"output": [
		{"name": "プロパティ名",  "type": "データタイプ"}
	]
}
```

ファイルの格納場所は「HIVE/HIVE/ModuleSystem/moduledata/」

ここにモジュール単位でディレクトリを作り、info.json と Lua スクリプトを一緒に配置する。

パネルを表示してインターフェースを提供する場合は、別途 JSX ファイルを同梱する。

### 重要な info.json のキー

* name
* funcname
* info
* customfuncfile
* input
  - name
  - type
* output
  - name
  - type

> インプットとアウトプットは必ずしもあるとは限らないので任意
> インプットなどは設定する場合は後述するデータタイプの指定などに注意

### データタイプ

データタイプは、Lua スクリプトでどのように入出力が処理されているかにもよって決まる。基本的なデータ型の他、カスタマイズされた型を独自に定義することもできる。

基本的なデータ型は以下。

* bool
* int
* float
* floatarray
* vec2
* vec3
* vec4
* string

### プロパティの項目数を可変長で扱う

インプットプロパティの項目自体を可変長で扱いたい場合は次に示すように `array` キーを使った定義を行う。

```
"input": [
  {"name": "RenderObject", "type": "RenderObject", "array": [
    {"name": "RenderObject[0]", "type": "RenderObject"},
    {"name": "RenderObject[1]", "type": "RenderObject"},
    {"name": "RenderObject[2]", "type": "RenderObject"}
  ]}
]
```

> 上記はあくまでもプロパティの項目を可変長として扱いたい場合
> プロパティの値を可変長として扱いたい場合には floatarray などを用いて配列として扱う
> ベクトルなどは vec3 などの型があるのでそちらを利用する

### その他の特殊なキー

#### uifile

このキーはパネルを持つモジュールで利用する場合がある。

パネルを持つモジュールの場合、パネルの動作を定義する JSX を記述することになるが、この JSX が外部ファイルや、別の JSX で記述されたコンポーネントを必要とする場合がある。

uifile キーはこういった外部ファイルをまとめてひとつにバンドルするために用いられ、対象となるファイルを配列で定義することにより自動的にバンドルされる。なお、ファイルは全て同じディレクトリ内に配置されている必要がある。

#### input.hole

このキーに `false` が設定されていると、最終的にノードエディタ上に表示される際にプラグ端子が非表示となる。

プロパティとしては存在させておきたいが、プラグを経由したインプットをさせたくない場合に用いる。プラグ経由での入力ができないとうだけで、プロパティペインからの直接編集は可能な点に注意。

#### input.visible

このキーに `false` が設定されていると、ノードエディタ上に表示される際に完全にプロパティが非表示となる。

パネルの外観に関するパラメータ等、プロパティとしては存在させておきたいが表には出さない（ユーザーが直接値を編集することができないようにしたい）場合に用いる。

> 例：
> パネル内で描画のみに利用するパラメータ等に利用する。たとえばあくまでも内部的に必要なフラグで、ユーザーが操作できないようにしておきたい場合など。

#### input.funcinput

このキーに `false` が設定されているプロパティは、更新を行ってもモジュールのリロードは行われない。

たとえば負荷の高い描画を行っている、あるいは巨大なデータをやりとりする、といったようなパネルを備えているモジュールの場合、何度もリロードや再描画を行うことが大きな負担となり、アプリケーションの利用に支障をきたす場合がある。

そのようなケースではこのキーを活用することで、外見上のアップデートなどは通常通り行いながら、モジュールそのもののリロードは抑えるといった動作を実現できる。

> 例：
> パラレルコーディネートでグラフを作図する際に、ユーザーが一部のデータを選択するなどのアクションを起こした際、毎回ボリュームデータを受け取る（リロードする）のは負荷が大きいため避けたい。
> しかし UI 上でのユーザーの操作の結果はプロパティに反映（更新）させたい。


## lua

Lua スクリプトにはモジュールのインプットとアウトプットをどのように処理するのかを記述する。

入出力を定義する上での最小構成は、たとえば以下のようになる。

記述例：

```
Slider = {}
setmetatable(Slider, {__index = HiveBaseModule})

Slider.new = function (varname)
    local this = HiveBaseModule.new(varname)
    setmetatable(this, {__index=Slider})
    return this
end

function Slider:Do()
    self:UpdateValue()
    return true
end

function Slider:fval()
    local v = self.value
    return v.value
end
```

まずモジュールそのものを格納するための Lua のテーブルを定義し `HiveBaseModule` を継承した擬似クラスを定義する。

その後、`new` プロパティにコンストラクタに相当する処理を記述したあと、入出力に関する処理をメソッドとして実装する。特に `モジュール名:Do()` は入力を受け取った際に動作するので、入力を取りたいのであれば必須。

当然ながら info.json で定義したモジュールの入出力の定義と内容が合致している必要がある点に注意。


## JSX ファイル

JSX ファイルはモジュールにパネルを付随させる際に必要。javascript をベースにした独自構文（とは言えほとんど JS と同じ）を利用する。

JSX の特徴として、DOM の構成やそれらの CSS スタイルなどをひとつのファイル内に記述できる点があり、これはモジュールのカプセル化と、コンポーネントとしての再利用がしやすさというメリットを生んでいる。

また Module System では、JSX を記述する上では React + Flux の概念を採用している。
